#pragma once
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Important note
// --------------------
// Since this class using std::atomic, some template parameters do not have specialization for operators 
// like "+=", "-=", "*=", "/=". So there is why you can find code like this:
//     x = x + right.x;
//     y = y + right.y;
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>::AtomicVector2() : x(0), y(0)
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>::AtomicVector2(const T xValue, const T yValue) : x(xValue), y(yValue)
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>::AtomicVector2(const AtomicVector2& other) : x(other.x.load()), y(other.y.load())
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>::AtomicVector2(AtomicVector2&& other) noexcept : x(std::move(other.x.load())), y(std::move(other.y.load()))
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
template <typename U>
AtomicVector2<T>::AtomicVector2(const AtomicVector2<U>& other) : x(other.x.load()), y(other.y.load())
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
template <typename U>
AtomicVector2<T>::AtomicVector2(AtomicVector2<U>&& other) : x(std::move(other.x.load())), y(std::move(other.y.load()))
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator=(const AtomicVector2& other)
{
    x = other.x.load();
    y = other.y.load();

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator=(AtomicVector2&& other) noexcept
{
    x = std::move(other.x.load());
    y = std::move(other.y.load());

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
template <typename U>
AtomicVector2<T>& AtomicVector2<T>::operator=(const AtomicVector2<U>& other)
{
    x = other.x.load();
    y = other.y.load();

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
template <typename U>
AtomicVector2<T>& AtomicVector2<T>::operator=(AtomicVector2<U>&& other)
{
    x = std::move(other.x.load());
    y = std::move(other.y.load());

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
bool AtomicVector2<T>::operator==(const AtomicVector2& right)
{
    return ((x == right.x) && (y == right.y));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
bool AtomicVector2<T>::operator!=(const AtomicVector2& right)
{
    return !(*this == right);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
T AtomicVector2<T>::operator*(const AtomicVector2& right) const
{
    return (x * right.x + y * right.y);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T> AtomicVector2<T>::operator*(const T scalar) const
{
    return AtomicVector2<T>(x * scalar, y * scalar);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T> AtomicVector2<T>::operator/(const T scalar) const
{
    const T invertedScalar = 1.0 / scalar;

    return AtomicVector2<T>(x * invertedScalar, y * invertedScalar);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T> AtomicVector2<T>::operator+(const AtomicVector2& right) const
{
    return AtomicVector2<T>(x + right.x, y + right.y);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T> AtomicVector2<T>::operator-(const AtomicVector2& right) const
{
    return AtomicVector2<T>(x - right.x, y - right.y);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator+=(const AtomicVector2& right)
{
    x = x + right.x;
    y = y + right.y;

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator-=(const AtomicVector2& right)
{
    x = x - right.x;
    y = y - right.y;

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator/=(const AtomicVector2& right)
{
    x = x / right.x;
    y = y / right.y;

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator/=(const T scalar)
{
    const T invertedScalar = 1.0 / scalar;
    x = x * invertedScalar;
    y = y * invertedScalar;

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T>& AtomicVector2<T>::operator*=(const T scalar)
{
    x = x * scalar;
    y = y *scalar;

    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T> operator-(const AtomicVector2<T>& right)
{
    return AtomicVector2<T>(-right.x, -right.y);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AtomicVector2<T> operator*(const T scalar, const AtomicVector2<T>& right)
{
    return AtomicVector2<T>(right.x * scalar, right.y * scalar);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void AtomicVector2<T>::Zero()
{
    x = y = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
